<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0">
    <title>Dungeons & Degenerate Gamblers</title>
    <style>
html, body, #canvas {
  margin: 0;
  padding: 0;
  border: 0;
}

body {
  color: white;
  background-color: black;
  overflow: hidden;
  touch-action: none;
}

#canvas {
  display: block;
}

#canvas:focus {
  outline: none;
}

#status, #status-splash, #status-progress {
  position: absolute;
  left: 0;
  right: 0;
}

#status, #status-splash {
  top: 0;
  bottom: 0;
}

#status {
  background-color: #242424;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  visibility: hidden;
}

#status-splash {
  max-height: 100%;
  max-width: 100%;
  margin: auto;
}

#status-splash.show-image--false {
  display: none;
}

#status-splash.fullsize--true {
  height: 100%;
  width: 100%;
  object-fit: contain;
}

#status-splash.use-filter--false {
  image-rendering: pixelated;
}

#status-progress, #status-notice {
  display: none;
}

#status-progress {
  bottom: 10%;
  width: 50%;
  margin: 0 auto;
}

#status-notice {
  background-color: #5b3943;
  border-radius: 0.5rem;
  border: 1px solid #9b3943;
  color: #e0e0e0;
  font-family: 'Noto Sans', 'Droid Sans', Arial, sans-serif;
  line-height: 1.3;
  margin: 0 2rem;
  overflow: hidden;
  padding: 1rem;
  text-align: center;
  z-index: 1;
}
    </style>

    <link id="-gd-engine-icon"
          rel="icon"
          type="image/png"
          href="index.icon.png" />
    <link rel="apple-touch-icon" href="index.apple-touch-icon.png" />
  </head>

  <body>
    <canvas id="canvas">
      Your browser does not support the canvas tag.
    </canvas>

    <noscript>
      Your browser does not support JavaScript.
    </noscript>

    <div id="status">
      <img id="status-splash"
           class="show-image--true fullsize--true use-filter--false"
           src="index.png"
           alt="">
      <progress id="status-progress"></progress>
      <div id="status-notice"></div>
    </div>

    <script src="index.js"></script>
    <script>
const GODOT_CONFIG = {
  args: [],
  canvasResizePolicy: 2,
  ensureCrossOriginIsolationHeaders: true,
  executable: "index",              // index.wasm
  experimentalVK: false,
  fileSizes: {                      // original sizes, optional
    "index.pck": 160952720,
    "index.wasm": 43699190
  },
  focusCanvas: true,
  gdextensionLibs: []
};
const GODOT_THREADS_ENABLED = false;

// chunks/index.pck.part0000 ... 0006 next to this file
const INDEX_PCK_CHUNKS = [
  "chunks/index.pck.part0000",
  "chunks/index.pck.part0001",
  "chunks/index.pck.part0002",
  "chunks/index.pck.part0003",
  "chunks/index.pck.part0004",
  "chunks/index.pck.part0005",
  "chunks/index.pck.part0006"
];

// --- chunk helpers (Unity-style, but for a single .pck) ---

async function fetchWithProgress(url, onProgress) {
  const res = await fetch(url);
  if (!res.ok) throw new Error("Failed to fetch " + url + " (" + res.status + ")");
  const reader = res.body.getReader();
  const chunks = [];
  let received = 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value);
    received += value.length;
    if (onProgress) onProgress(value.length);
  }

  const buffer = new Uint8Array(received);
  let offset = 0;
  for (const chunk of chunks) {
    buffer.set(chunk, offset);
    offset += chunk.length;
  }
  return buffer.buffer;
}

async function mergePckChunks(onProgress) {
  const buffers = [];
  for (const url of INDEX_PCK_CHUNKS) {
    const buf = await fetchWithProgress(url, onProgress);
    buffers.push(new Uint8Array(buf));
  }

  // Concatenate into one Uint8Array (the real index.pck bytes)
  let total = 0;
  for (const b of buffers) total += b.byteLength;
  const merged = new Uint8Array(total);
  let offset = 0;
  for (const b of buffers) {
    merged.set(b, offset);
    offset += b.byteLength;
  }
  return merged.buffer;          // ArrayBuffer, not Blob URL
}

// --- Godot startup using merged pack URL ---

const engine = new Engine(GODOT_CONFIG);

(function () {
  const statusOverlay = document.getElementById("status");
  const statusProgress = document.getElementById("status-progress");
  const statusNotice = document.getElementById("status-notice");

  let initializing = true;
  let statusMode = "";

  function setStatusMode(mode) {
    if (statusMode === mode || !initializing) return;
    if (mode === "hidden") {
      statusOverlay.remove();
      initializing = false;
      return;
    }
    statusOverlay.style.visibility = "visible";
    statusProgress.style.display = mode === "progress" ? "block" : "none";
    statusNotice.style.display = mode === "notice" ? "block" : "none";
    statusMode = mode;
  }

  function setStatusNotice(text) {
    while (statusNotice.lastChild) {
      statusNotice.removeChild(statusNotice.lastChild);
    }
    const lines = text.split("\n");
    lines.forEach((line) => {
      statusNotice.appendChild(document.createTextNode(line));
      statusNotice.appendChild(document.createElement("br"));
    });
  }

  function displayFailureNotice(err) {
    console.error(err);
    if (err instanceof Error) {
      setStatusNotice(err.message);
    } else if (typeof err === "string") {
      setStatusNotice(err);
    } else {
      setStatusNotice("An unknown error occurred.");
    }
    setStatusMode("notice");
    initializing = false;
  }

  const missing = Engine.getMissingFeatures({
    threads: GODOT_THREADS_ENABLED
  });

  if (missing.length !== 0) {
    const missingMsg =
      "Error\nThe following features required to run Godot projects on the Web are missing:\n";
    displayFailureNotice(missingMsg + missing.join("\n"));
    return;
  }

  setStatusMode("progress");

  // 1) Merge chunks -> blob URL for index.pck
  mergePckChunks(() => {
  statusProgress.removeAttribute("max");
  statusProgress.removeAttribute("value");
})
  .then((pckBuffer) => {
    // Put the reconstructed pack into Godot's virtual FS
    // First arg: data (ArrayBuffer), second: path inside FS. [web:37][web:59]
    return engine
      .init(GODOT_CONFIG.executable)           // "index" -> loads index.wasm
      .then(() => engine.preloadFile(pckBuffer, "/index.pck"))
      .then(() => engine.start({
        args: ["--main-pack", "/index.pck"]
      }));
  })
  .then(() => {
    setStatusMode("hidden");
  })
  .catch(displayFailureNotice);

}());
    </script>
  </body>
</html>
